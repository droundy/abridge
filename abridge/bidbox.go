package main

import (
	"fmt"
	"regexp"
	"os"
	"io"
	"http"
	"github.com/droundy/bridge"
	"github.com/ajstarks/svgo"
)

func readbidbox(req *http.Request, dat *TransitoryData) {
	if d, ok := req.Form["dealer"]; ok && len(d) == 1 {
		dat.Dealer = bridge.StringToSeat(d[0])
	}
	if d, ok := req.Form["nscard"]; ok {
		dat.NScard = d[0]
	}
	if d, ok := req.Form["ewcard"]; ok {
		dat.EWcard = d[0]
	}
	if _,ok := req.Form["refresh"]; ok {
		bridge.ClearBid(dat.Bids)
	}
}

func bidbox(c io.Writer, req *http.Request, dat *TransitoryData) os.Error {
	p := getSettings(req)
	candouble := regexp.MustCompile(".[CDHSN]( P P)?$").MatchString(dat.Bids)
	canredouble := regexp.MustCompile(" X( P P)?$").MatchString(dat.Bids)
	bv, bs := bridge.LastBid(dat.Bids)
	//cc := [2]bridge.ConventionCard{ *getSettings(req).Cards[dat.NScard], *getSettings(req).Cards[dat.EWcard] }
	cc := bridge.DefaultConventions()
	if dat == nil {
		fmt.Println("dat is nil")
	}
	fmt.Println("dat.Bids is", dat.Bids)
	nextbids := bridge.RateNextBids(dat.Bids, cc)
	go bridge.ContemplateBid(dat.Bids, cc)
	
	fmt.Fprintf(c, `<div id="bidbox" style="position:relative; left:0; right:0">`)

	s := svg.New(c)
	// Start begins a new XML document!
	//s.Start(500, 500)
	fmt.Fprintf(c, `<!-- Generated by SVGo -->
        <svg id="logo" xmlns="http://www.w3.org/2000/svg"
             xmlns:xlink="http://www.w3.org/1999/xlink"
             preserveAspectRatio="xMidYMid slice"
             width="%d" height="%d">`, 205, 300)
	gradients := make(map[int]string)
	getgrad := func(f float64) string {
		intval := int(100*f)
		if x,ok := gradients[intval]; ok {
			return x
		}
		x := fmt.Sprintf("grad%02d", intval)
		switch {
		case f < 0.5:
			ff := 1-f*2
			color := fmt.Sprintf("#%02x%02x%02x", 255, int(ff*255.5), 0)
			s.RadialGradient(x, 50, 50, 70, 50, 50,
				[]svg.Offcolor{svg.Offcolor{0,color,1}, svg.Offcolor{60,color,0}})
		default:
			ff := 2 - f*2
			color := fmt.Sprintf("#%02x%02x%02x", int(ff*255.5), 0, 0)
			s.RadialGradient(x, 50, 50, 70, 50, 50,
				[]svg.Offcolor{svg.Offcolor{0,color,1}, svg.Offcolor{60,color,0}})
		}
		name := "fill:url(#" + x + ")"
		gradients[intval] = name
		return name
	}
	s.RadialGradient("green", 50, 50, 70, 50, 50,
		[]svg.Offcolor{svg.Offcolor{0,"#ff0000",1}, svg.Offcolor{60,"#ff0000",0}})
	if p := nextbids[" P"]; p > 0 {
		s.Circle(20, 18, 25, getgrad(p))
	}
	if p, ok := nextbids[" X"]; ok && p > 0 {
		s.Circle(20+50, 18, 25, getgrad(p))
	}
	if p, ok := nextbids["XX"]; ok && p > 0 {
		s.Circle(20+2*50, 18, 25, getgrad(p))
	}
	for bidlevel:=1;bidlevel<8;bidlevel++ {
		yval := 14 + (30+4)*bidlevel
		for sv:=bridge.Color(bridge.Clubs); sv<=bridge.NoTrump; sv++ {
			xval := 20 + 50*int(sv)
			if bidlevel > bv || (bidlevel == bv && sv > bs) {
				b := fmt.Sprintf("%d%v", bidlevel, bridge.SuitLetter[sv])
				if p := nextbids[b]; p > 0 {
					fmt.Println("For bid", b, "we have score", nextbids[b])
					s.Circle(xval, yval, 25, getgrad(p))
				}
			}
		}
	}
	s.End()

	fmt.Fprintln(c, `<table width="250px"><tr>
<td><input type="submit" name="bid" value=" P" /></td>`)
	if candouble {
		fmt.Fprintln(c, `<td width="20%" align="center"><input type="submit" name="bid" value=" X" /></td>`)
	} else {
		fmt.Fprintln(c, `<td width="20%" align="center"><span class="disablednotrump">X</span></td>`)
	}
	if canredouble {
		fmt.Fprintln(c, `<td width="20%" align="center"><input type="submit" name="bid" value="XX" /></td></tr>`)
	} else {
		fmt.Fprintln(c, `<td width="20%" align="center"><span class="disablednotrump">XX</span></td></tr>`)
	}
	for bidlevel:=1;bidlevel<8;bidlevel++ {
		fmt.Fprintln(c, "<tr>")
		for sv:=bridge.Color(bridge.Clubs); sv<=bridge.NoTrump; sv++ {
			fmt.Fprint(c, `<td height="30px" width="20%" align="center">`)
			if bidlevel > bv || (bidlevel == bv && sv > bs) {
				fmt.Fprintf(c, `<input type="submit" name="bid" class="%s" value="%d%v" /></td>`,
					bridge.SuitName[sv], bidlevel, bridge.SuitHTML[sv])
			} else {
				fmt.Fprintf(c, `<span class="disabled%s">%d%v</span></td>`,
					bridge.SuitName[sv], bidlevel, bridge.SuitHTML[sv])
			}
		}
		fmt.Fprintln(c, "</tr>")
	}
	fmt.Fprintln(c, `</table><input type="submit" name="clear" value="Next hand" />`)
	fmt.Fprintln(c, `<input type="submit" name="undo" value="Undo" />`)
	fmt.Fprintln(c, `<input type="submit" name="refresh" value="Refresh" />`)
	fmt.Fprintln(c, `<br/>`)
	fmt.Fprintln(c, `<br/>`)
	var seats = []string{"S", "W", "N", "E"}
	for s,v := range seats {
		if dat.Dealer != bridge.Seat(s) && dat.Bids == "" {
			fmt.Fprintf(c, `<input type="submit" name="dealer" value="%s" />`, v)
		} else {
			fmt.Fprintf(c, `<input type="submit" disabled="disabled" value="%s" />`, v)
		}
	}

	// Set cards to default values, if they aren't yet initialized...
	if _,ok := p.Cards[dat.NScard]; !ok {
		dat.NScard = p.WhichCard
	}
	if _,ok := p.Cards[dat.EWcard]; !ok {
		dat.EWcard = p.WhichCard
	}
	fmt.Fprintln(c, `<br/>NS: <select name="nscard">`)
	for k := range p.Cards {
		fmt.Fprint(c, `<option value="`, k, `"`)
		if k == dat.NScard {
			fmt.Fprint(c, ` selected="selected"`)
		}
		fmt.Fprintln(c, `>`, k, `</option>`)
	}
	fmt.Fprintln(c, `</select>`)

	fmt.Fprintln(c, `EW: <select name="ewcard">`)
	for k := range p.Cards {
		fmt.Fprint(c, `<option value="`, k, `"`)
		if k == dat.EWcard {
			fmt.Fprint(c, ` selected="selected"`)
		}
		fmt.Fprintln(c, `>`, k, `</option>`)
	}
	fmt.Fprintln(c, `</select>`)


	fmt.Fprintln(c, `</div>`)
	return nil
}
